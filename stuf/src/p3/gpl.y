// Mon Apr 27 16:03:16 PDT 2020
// bison syntax indicating C++ declarations required by both the parser and scanner
%code requires {
  #include <string>
  #include "Scope_manager.h"
  class Expression;
  class Variable;
  struct Parameter;
  class Statement;
  #ifndef P1
    #include "types_and_ops.h"  //include in all projects except the first
    using namespace GPL;
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif
  #include "Constant.h"
  #include "Variable.h"
  
}

// bison syntax to indicate the beginning of a C/C++ code section
%{

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include <iostream>

// bison syntax indicating the end of a C/C++ code section

%} 


/*
 * This template can be put near the top of gpl.y. It captures the
 * type-checking that is required before creating a binary operator object.
 * it greatly reduces the amount of code embedded in each binary operator
 * action.
 */


/*Example usage of template in the action of a binary operator
    | expression T_PLUS expression { $$=Bin_op_check<Plus, PLUS>($1, $3, INT|DOUBLE|STRING); }
    */

// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 GPL::Type union_gpl_type;
 int            union_int;
 double         union_double;
 std::string*   union_string;  // MUST be a pointer to a string
 const Expression* union_expression_ptr;
 const Variable* union_variable_ptr;
};
%destructor { delete $$; } <union_string>


// tokens declared here
%{
template<typename OP, GPL::Operator optype>
const Expression* Bin_op_check(const Expression* one, const Expression* three, unsigned int valid_types)
{ 
  bool lhs_valid=one->type() & valid_types;
  bool rhs_valid=three->type() & valid_types;
  if(lhs_valid && rhs_valid)
    return new OP(one, three); 
  if(!lhs_valid) { Error::error(Error::INVALID_LEFT_OPERAND_TYPE,  to_string(optype)); }
  if(!rhs_valid) { Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, to_string(optype)); }
  delete one;
  delete three;
  return new Integer_constant(0);
}
template<typename OP, GPL::Operator optype>
const Expression* Un_op_check(const Expression* one, unsigned int valid_types)
{ 
  bool rhs_valid=one->type() & valid_types;
  if(rhs_valid )
  {
    if(optype == RANDOM)
    {

        if(one->type() == DOUBLE)
        {
            if(one->evaluate()->as_double()<1)
            {
                Error::error(Error::INVALID_ARGUMENT_FOR_RANDOM,  std::to_string(one->evaluate()->as_double()));

            }
        }
        else
        {
            if(one->evaluate()->as_int()<1)
            {
                Error::error(Error::INVALID_ARGUMENT_FOR_RANDOM,  std::to_string(one->evaluate()->as_int()));

            }
        }
        
    }
    return new OP(one); 
  }
  if(!rhs_valid) { Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,  to_string(optype)); }
  delete one;
  return new Integer_constant(0);
}
%}

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token T_FORWARD             "forward"
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT            "exit"  /* value is line number */
%token <union_int> T_PRINT           "print"  /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"
%token UNARY_OPS            
%token IF_NO_ELSE

%token <union_int> T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID;
%type <union_gpl_type> simple_type;
%type <union_expression_ptr> primary_expression;
%type <union_expression_ptr> expression;
%type <union_expression_ptr> optional_initializer;
%type <union_variable_ptr> variable;


 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"
/* Bitwise Comma , */
/* Bitwise Assignment = += -= *= /= %= >>= <<= &= ^= |=*/
/* Bitwise Conditional ? */
/* Bitwise Logical OR || */
/* Bitwise Logical And && */
/* Bitwise OR | */
/*Bitwise XOR ^ */
/*Bitwise AND & */
/*Equality == != */
/*Relational < <= > >=*/
/*Shift << >>*/
%nonassoc IF_NO_ELSE
%nonassoc T_ELSE
%left T_OR
%left T_AND 
%left T_EQUAL T_NOT_EQUAL 
%left T_LESS T_LESS_EQUAL T_GREATER T_GREATER_EQUAL 

%left T_PLUS T_MINUS /*Additive*/
%left T_MULTIPLY T_DIVIDE T_MOD/*Multiplicative*/
/*Unary + - ! ~ ++ -- (type)* & sizeof */
%nonassoc UNARY_OPS 
%nonassoc T_NOT
/*Postfix () [] -> . ++ -- */
%nonassoc T_NEAR T_TOUCHES

%%

// updated October 2021

//---------------------------------------------------------------------
program:
    declaration_list block_list


//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | %empty


//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC


//---------------------------------------------------------------------
variable_declaration:
    simple_type  T_ID  optional_initializer
    {
        Scope_manager& scopemgr=Scope_manager::instance();//how to refere to scope manager
        if(scopemgr.defined_in_current_scope(*$2))
        {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
            delete $2;
            break;
        }
        try
        {
            switch($1)
            {
                case GPL::INT:
                {
                    cout <<"issue in INT\n";
                    int* ptr = new int($3==nullptr ? 0 : $3->evaluate()->as_int());   
                    scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr));
                    break;
                }//int
                case GPL::DOUBLE:
                {
                    double* ptr;
                    if($3==nullptr)
                    {
                        ptr = new double(0.0);
                    }
                    else
                        ptr= new double($3->evaluate()->as_double());
                    scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr));
                    break;
                }//double
                case GPL::STRING:
                {
                    std::string* ptr;
                    if($3==nullptr)
                    {
                        ptr = new std::string("");
                    }
                    else
                        ptr = new std::string($3->evaluate()->as_string());
                    scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr));
                    break;
                }//string
                default:
                {
                    assert(false);
                }//default case
            }//switch
        }//try block
        catch(GPL::Type actual_type)
        {
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE,
            GPL::to_string(actual_type), *$2, GPL::to_string($1));
            switch($1)
            {
                case GPL::INT:
                {
                    scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, new int(0)));
                    break;
                }
                case GPL::DOUBLE:
                {
                    scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, new double(0.0)));
                    break;
                }
                case GPL::STRING:
                {
                    scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2, new std::string("")));
                    break;
                } 
                default:
                {
                assert(false);
                }
            }
            
        }
        delete $2;
        delete $3;
        
    }
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET
    {
        if($4->evaluate()->type() == GPL::STRING)
        {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER,"string",*$2);
            delete $2;
            break;
        }
        if($4->evaluate()->type() == GPL::DOUBLE)
        {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER,"double",*$2);
            delete $2;
            break;
        }
        const int array_size = $4->evaluate()->as_int();
        Scope_manager& scopemgr=Scope_manager::instance();//how to refere to scope manager
        
        if(scopemgr.defined_in_current_scope(*$2))
        {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
            delete $2;
            break;
        }
        if(array_size < 0)
        {
            Error::error(Error::INVALID_ARRAY_SIZE,*$2,std::to_string(array_size));
            delete $2;
            break;
        }
        else{
            try{
                switch($1)
                {
                    case GPL::INT:
                    {
                        int* ptr = new int[array_size]{0};
                        // for(auto i = 0; i < $4; ++i)
                        // {
                        // }
                        for(auto i = 0; i < array_size; ++i)
                        {
                            ptr[i] = 0;
                        }
                        scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr,array_size));
                        
                        delete $2;
                        //std::cout <<"this is the value for argument 4 " << $4 <<"\n";
                        break;
                    }
                    case GPL::DOUBLE:
                    {
                        double* ptr = new double[array_size];
                        for(auto i = 0; i < array_size; ++i)
                        {
                            ptr[i] = 0.0;
                        }
                        scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr,array_size));
                        delete $2;
                        break;
                    }
                    case GPL::STRING:
                    {
                        std::string* ptr = new std::string[array_size];
                        for(auto i = 0; i < array_size; ++i)
                        {
                            ptr[i] = "";
                        }
                        scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr,array_size));
                        delete $2;
                        break;
                    }
                    default:
                    {
                        assert(false);
                    }
                }//swithc
            }//try
            catch(GPL::Type actual_type)
            {
                Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE,
                GPL::to_string(actual_type), *$2, GPL::to_string($1));
                switch($1)
                {
                    case GPL::INT:
                    {
                        int* ptr = new int[array_size]{0};
                        scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr,array_size));
                        break;
                    }
                    case GPL::DOUBLE:
                    {
                        double* ptr = new double[array_size]{0.0};
                        scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr,array_size));
                        break;
                    }
                    case GPL::STRING:
                    {
                        std::string* ptr = new std::string[array_size]{""};
                        scopemgr.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr,array_size));
                        break;
                    } 
                    default:
                    {
                    assert(false);
                    }
                }
                
            }   
        }
        
    }

//---------------------------------------------------------------------
simple_type:
    T_INT       {$$=GPL::INT;}
    | T_DOUBLE  {$$=GPL::DOUBLE;}
    | T_STRING  {$$=GPL::STRING;}


//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression {$$=$2;cout <<"==="<<$2->evaluate()->as_int()<<"\n";}
    | %empty {$$=nullptr;cout <<"optional2\n";}


//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty {$2; /*Change*/}
    | object_type T_ID T_LBRACKET expression T_RBRACKET {$2; /*Change*/}


//---------------------------------------------------------------------
object_type:
    T_TRIANGLE
    | T_PIXMAP
    | T_CIRCLE
    | T_RECTANGLE
    | T_TEXTBOX


//---------------------------------------------------------------------
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN
    | T_LPAREN T_RPAREN
    | %empty


//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter
    | parameter


//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression


//---------------------------------------------------------------------
block_list:
    block_list block
    | %empty


//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block


//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block


//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block


//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN { $3; /*Change*/}


//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID { $2; /*Change*/}
    | object_type


//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block


//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN { $2; $5;/*Change*/}


//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block


//---------------------------------------------------------------------
keystroke:
    T_SPACE
    | T_UPARROW
    | T_DOWNARROW
    | T_LEFTARROW
    | T_RIGHTARROW
    | T_LEFTMOUSE_DOWN
    | T_MIDDLEMOUSE_DOWN
    | T_RIGHTMOUSE_DOWN
    | T_LEFTMOUSE_UP
    | T_MIDDLEMOUSE_UP
    | T_RIGHTMOUSE_UP
    | T_MOUSE_MOVE
    | T_MOUSE_DRAG
    | T_AKEY
    | T_SKEY
    | T_DKEY
    | T_FKEY
    | T_HKEY
    | T_JKEY
    | T_KKEY
    | T_LKEY
    | T_WKEY
    | T_ZKEY
    | T_F1


//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement


//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE
    | T_LBRACE T_RBRACE



//---------------------------------------------------------------------
statement_list:
    statement_list statement
    | statement


//---------------------------------------------------------------------
statement:
    if_statement
    | for_statement
    | assign_statement T_SEMIC
    | print_statement T_SEMIC
    | exit_statement T_SEMIC


//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec IF_NO_ELSE
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements 


//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements


//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN


//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN


//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement
    | %empty


//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression{cout<<"in here12\n";}
    | variable T_PLUS_ASSIGN expression
    | variable T_MINUS_ASSIGN expression
    | variable T_PLUS_PLUS
    | variable T_MINUS_MINUS


//---------------------------------------------------------------------
variable:
    T_ID {
        Scope_manager& scope = Scope_manager::instance();
        auto sym = scope.lookup(*$1);
        cout << "inside t_id\n";
        if(sym==nullptr)
        {
            Error::error(Error::UNDECLARED_VARIABLE,*$1);
            $$ = new Variable("");
            delete $1;
            break;
        }
        if(sym->get_count()>0)
        {
            Error::error(Error::VARIABLE_IS_AN_ARRAY,*$1);
            $$ = new Variable("");
            delete $1;
            break;
        }
        cout <<"1"<<"\n";
        cout <<*$1<<"\n";
        $$ = new Variable(*$1);
        cout <<"2"<<"\n";
        delete $1;
        cout <<"3"<<"\n";
    }
    | T_ID T_LBRACKET expression T_RBRACKET{cout<<"in here2\n";}
    | T_ID T_PERIOD T_ID { $1;$3; cout<<"in here3\n";/*Change*/}
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID { $1;$6; cout<<"in here4\n";/*Change*/}


//---------------------------------------------------------------------
expression:
    primary_expression {$$=$1;}
    | expression T_OR expression {$$=Bin_op_check<Or, OR>($1, $3, (INT|DOUBLE));}
    | expression T_AND expression {$$=Bin_op_check<And, AND>($1, $3, (INT|DOUBLE));}
    | expression T_LESS_EQUAL expression {$$=Bin_op_check<Less_equal, LESS_EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_GREATER_EQUAL  expression {$$=Bin_op_check<Greater_equal, LESS_EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_LESS expression {$$=Bin_op_check<Less_than, LESS_THAN>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_GREATER  expression {$$=Bin_op_check<Greater_than, GREATER_THAN>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_EQUAL expression {$$=Bin_op_check<Equal, EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_NOT_EQUAL expression {$$=Bin_op_check<Not_equal, NOT_EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_PLUS expression {$$=Bin_op_check<Plus, PLUS>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_MINUS expression {$$=Bin_op_check<Minus, MINUS>($1, $3, INT|DOUBLE);}
    | expression T_MULTIPLY expression {$$=Bin_op_check<Multiply, MULTIPLY>($1, $3, INT|DOUBLE);}
    | expression T_NEAR expression {$$=nullptr; /*CHANGE*/}
    | expression T_TOUCHES expression {$$=nullptr; /*CHANGE*/}
    | expression T_DIVIDE expression {$$=Bin_op_check<Divide, DIVIDE>($1, $3, INT|DOUBLE);}
    | expression T_MOD expression {$$=Bin_op_check<Mod, MOD>($1, $3, INT);}
    | T_MINUS  expression %prec UNARY_OPS {$$=Un_op_check<Unary_minus, UNARY_MINUS>($2, INT|DOUBLE);}
    | T_NOT  expression {$$=Un_op_check<Not, NOT>($2, INT|DOUBLE);}
    | T_SIN T_LPAREN expression T_RPAREN {$$=Un_op_check<Sin, SIN>($3, INT|DOUBLE);}
    | T_COS T_LPAREN expression T_RPAREN {$$=Un_op_check<Cos, COS>($3, INT|DOUBLE);}
    | T_TAN T_LPAREN expression T_RPAREN {$$=Un_op_check<Tan, TAN>($3, INT|DOUBLE);}
    | T_ASIN T_LPAREN expression T_RPAREN {$$=Un_op_check<Asin, ASIN>($3, INT|DOUBLE);}
    | T_ACOS T_LPAREN expression T_RPAREN {$$=Un_op_check<Acos, ACOS>($3, INT|DOUBLE);}
    | T_ATAN T_LPAREN expression T_RPAREN {$$=Un_op_check<Atan, ATAN>($3, INT|DOUBLE);}
    | T_SQRT T_LPAREN expression T_RPAREN {$$=Un_op_check<Sqrt, SQRT>($3, INT|DOUBLE);}
    | T_ABS T_LPAREN expression T_RPAREN {$$=Un_op_check<Abs, ABS>($3, INT|DOUBLE);}
    | T_FLOOR T_LPAREN expression T_RPAREN {$$=Un_op_check<Floor, FLOOR>($3, INT|DOUBLE);}
    | T_RANDOM T_LPAREN expression T_RPAREN {$$=Un_op_check<Random, RANDOM>($3, INT|DOUBLE);}


//---------------------------------------------------------------------
primary_expression:
    variable {$$=$1;cout<<"inside here\n";cout<<$1<<"\n";}
    | T_INT_CONSTANT { $$ = new Integer_constant($1);}
    | T_TRUE {$$=new Integer_constant(1);}
    | T_FALSE {$$=new Integer_constant(0);}
    | T_DOUBLE_CONSTANT {$$ = new Double_constant($1);}
    | T_STRING_CONSTANT {$$ = new String_constant(*$1);delete $1;}
    | T_LPAREN  expression T_RPAREN {$$=$2;/*CHANGE*/}
%%
